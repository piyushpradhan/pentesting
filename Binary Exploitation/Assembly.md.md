# Assembly Language

## Registers

- These are temporary storage of data. 
- General purpose registers: 
	1. 8085: a, c, d, b, e, h, l 
	2. 8086: ax, cx, dx, bx, **sp**, **bp**, si, di 
	3. x86: eax, ecx, edx, ebx, **esp**, **ebp**, esi, edi
	4. amd64: rax, rcx, rdx, rbx, **rsp**, **rbp**, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15
	5. arm: r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, **r13**, **r14**
- 8085 was an 8 bit architecture, pretty old compared to the modern architecture. It had 7 general purpose registers
- These registers were extended by Intel into eight 16-bit registers. 
- x86 extended it to 32 bit, *ax -> eax*  
- amd64 extended it to 64 bit, extending the amount of registers we had

- Some general purpose registers store a much specific data or tasks (in bold)

### Partial Register Access

- rax 's lower 32 bit can be accessed by eax
- eax 's lower 16 bit can be accessed by ax and so on.. 

```
rax 
	eax 
		ax 
			ah - al
```

## Instructions

- Syntax : OPCODE OPERAND OPERAND, ...
	- OPCODE - what to do 
	- OPERANDS - what to do it on/with
- Examples: 
```
mov rbx, rax
add eip, esp
```

### Data manipulation

- In intel's syntax, data flows from right to left
```
# rbx is moved into rax 
# Similar to rax = rbx 
mov rax, rbx

# [] -> memory acces 
# it loads 8 bytes into rax because rax is 8 bytes long
mov rax, [rbx + 4]

# result is stored in rax
add rax, rbx

# multiplies whatever is in the rax with the argument
mul rsi

inc rax 
inc [rax]
```

### Control flow 

- Unconditionals: call, jmp, ret
- Conditioinals : 
	- je -> jump if equal - ZF = 1
	- jne -> jump if not equal - ZF = 0
	- jg -> jump if greater - 
	- jl -> jump if less
	- jle -> jump if less than or equal 
	- jge -> jum if greater than or equal 
	- ja -> jump if above (unsigned)
	- jb -> jump if below (unsigned)
	- jae -> jump if above and equal (unsigned)
	- jbe -> jump if below and equal (unsigned)
	- js -> jump if signed
	- jns -> jump if not signed 
	- jo -> jump if overflow 
	- jno -> jump if not overflow 
	- jz -> jump if zero 
	- jnz -> jump if not zero 

```
cmp rax, rbx # the condition
jb some_location
```

### Conditionals

- flags register (exists on x86, amd64, arm)
- this contains a single bit, that is update by various operations
```
cmp rax, rbx
# if equal -> 1
# if not -> 0

sub rax, rbx
# SF - sign flag can be set
```

### System calls
- when a system call is triggered the program stops executing, the OS kernel takes over carries out the request and then returns control to the program 
- System calls on amd64 
	1. set rax *system call number*
	2. store arguments in rdi, rsi etc
	3. call the syscall instruction 

## Memory 

### Stack

Four main uses : 
1. Track the "callstack" of a program 
	a. return values are "pushed" to the stack during a call and "popped" during a ret
2. Contain local variables of functioins
3. Provide scratch space (to alleviate register exhaustion)
4. pass function arguments 

Relevant registers (amd64) : rsp, rbp 
Relevant instructions (amd64) : push, pop

### Other mapped regions 

- Functions like mmap and malloc can cause other regions of the memory to be mapped as well. 

### Endianess

- data is stored backwards in little endian (bytes are reversed)
- 
- Advantages: 
	- Performance 
	- Ease of addressing for different sizes 
	- 8086 compatibility